--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_innodb_max_16k.inc

SET @saved_innodb_compressed_columns_zip_level = @@global.innodb_compressed_columns_zip_level;

# creating a simple compression dictionary for future references
CREATE COMPRESSION_DICTIONARY numbers('one' 'two' 'three');

--let $table_name  = t1
--let $source_column_name = a
--let $source_column_type = BLOB
--let $generated_column_name = g
--let $generated_column_type = BLOB
--let $dictionary_name = numbers

--source suite/innodb/include/xtradb_compressed_columns_virtual_superset.inc

# setting zip level to 0 means skipping compressing for all values
# (compressed column header will still be added)
SET GLOBAL innodb_compressed_columns_zip_level = 0;

--source suite/innodb/include/xtradb_compressed_columns_virtual_superset.inc

# restoring default value
SET GLOBAL innodb_compressed_columns_zip_level = DEFAULT;

# creating a table with an index on a virtual column based on a compressed field
CREATE TABLE t1(
  f1 INT PRIMARY KEY,
  f2 BLOB COLUMN_FORMAT COMPRESSED,
  f3 BLOB GENERATED ALWAYS AS (f2) VIRTUAL,
  INDEX(f3(200))
) ROW_FORMAT=COMPRESSED, ENGINE=InnoDB;

INSERT INTO t1 (f1, f2) VALUES (1, REPEAT('a', 96));
# checking if changing table row format, which requires virtual values calculation, does not crash
ALTER TABLE t1 ROW_FORMAT=COMPACT;
# checking if deleting a row, which requires virtual values calculation in order to update the index,
# does not crash
DELETE FROM t1 WHERE f1 = 1;
DROP TABLE t1;


# checking if calculating virtual column values from current cluster index record data
# does not cause double locking of 'dict_operation_lock' / 'dict_sys->mutex' when reading
# zip dict data on opening an already open table
CREATE TABLE t (
  a BLOB COLUMN_FORMAT COMPRESSED WITH COMPRESSION_DICTIONARY numbers,
  c BLOB GENERATED ALWAYS AS (a) VIRTUAL,
  INDEX(c(100))
) ENGINE=InnoDB;

INSERT INTO t VALUES (REPEAT('a', 16000), DEFAULT);

SET GLOBAL debug="+d,ib_purge_virtual_index_callback";
UPDATE t SET a = REPEAT('m', 16000) WHERE a LIKE "aaa%";
SELECT SLEEP(3);
SET GLOBAL debug="-d,ib_purge_virtual_index_callback";
DROP TABLE t;


# checking if calculating virtual column values from the purge threads does not crash
SET GLOBAL innodb_purge_stop_now = 1;

# Index on a virtual column
CREATE TABLE t1(
  id INT not null,
  a BLOB NOT NULL COLUMN_FORMAT COMPRESSED WITH COMPRESSION_DICTIONARY numbers,
  vchar CHAR(2) AS (SUBSTR(a, 2, 2)) VIRTUAL,
  INDEX(vchar)
) ENGINE=InnoDB;

INSERT INTO t1 VALUES(1, REPEAT('a',8000), DEFAULT);

UPDATE t1 SET id = 5 where id = 1;
DELETE FROM t1 WHERE id = 5;

SET GLOBAL innodb_purge_run_now = 1;
--source include/wait_innodb_all_purged.inc
SET GLOBAL innodb_purge_stop_now = 1;
DROP TABLE t1;
SET GLOBAL innodb_purge_run_now = 1;

# cleanup
DROP COMPRESSION_DICTIONARY numbers;

SET GLOBAL innodb_compressed_columns_zip_level = @saved_innodb_compressed_columns_zip_level;
