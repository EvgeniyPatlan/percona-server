--source include/have_innodb.inc

# check if dictionary data supplied to "CREATE COMPRESSION_DICTIONARY ..."
# statements is the same as in the information_schema (NUL characters
# must not be ignored and must not be treaded as string terminators)

CREATE COMPRESSION_DICTIONARY d1('');
CREATE COMPRESSION_DICTIONARY d2(_ucs2'');
CREATE COMPRESSION_DICTIONARY d3('aaaaaaaabbbbbbbbccccccccdddddddd');
CREATE COMPRESSION_DICTIONARY d4(_ucs2'aaaaaaaabbbbbbbbccccccccdddddddd');

CREATE COMPRESSION_DICTIONARY d5(' ');
CREATE COMPRESSION_DICTIONARY d6('\0');
CREATE COMPRESSION_DICTIONARY d7('\0aaaaaaaabbbbbbbbccccccccdddddddd');

# check if it is possible to create a compression dictionary with
# string data passed via variable
SET @dict_data8 = 'aaaaaaaabbbbbbbbccccccccdddddddd';
CREATE COMPRESSION_DICTIONARY d8(@dict_data8);

# variable containing empty string
SET @dict_data9 = '';
CREATE COMPRESSION_DICTIONARY d9(@dict_data9);

# numeric variable
SET @dict_data10 = 123;
CREATE COMPRESSION_DICTIONARY d10(@dict_data10);

# variable of DATETIME type
SET @dict_data11 = STR_TO_DATE('02/29/2016', '%m/%d/%Y');
CREATE COMPRESSION_DICTIONARY d11(@dict_data11);

# NULL variable
SET @dict_data12 = NULL;
CREATE COMPRESSION_DICTIONARY d12(@dict_data12);

# "CREATE COMPRESSION_DICTIONARY <dict>(@<var> := <expr>)" must
# generate a syntax error
--error ER_PARSE_ERROR
CREATE COMPRESSION_DICTIONARY d12(@dict_data12 := 'blah');

# max dictionary name length is 64 characters - check if an
# error is reported if this number is exceeded
SET @long_dictionary_name = REPEAT('d', 64);
--let $long_dictionary_name=`SELECT @long_dictionary_name`
--eval CREATE COMPRESSION_DICTIONARY $long_dictionary_name('abcd')

--error ER_COMPRESSION_DICTIONARY_NAME_TOO_LONG
--eval CREATE COMPRESSION_DICTIONARY d$long_dictionary_name('abcd')

# max dictionary data size is 32506 bytes - check if an error
# is reported if this number is exceeded
SET @long_dictionary_data = REPEAT('ab', 32506 / 2);
CREATE COMPRESSION_DICTIONARY d13(@long_dictionary_data);

SET @longer_dictionary_data = CONCAT(@long_dictionary_data, 'a');
--error ER_COMPRESSION_DICTIONARY_DATA_TOO_LONG
CREATE COMPRESSION_DICTIONARY d14(@longer_dictionary_data);

# we use MD5() function here to get rid of NUL characters in the output
SELECT id, name, MD5(zip_dict), LENGTH(zip_dict)
  FROM information_schema.xtradb_zip_dict
  ORDER BY id;

# check if dictionary data stored in SYS_ZIP_DICT can be extracted
# without corruption
SELECT zip_dict = 'abcd' AS short_zip_dict_data_must_match
  FROM information_schema.xtradb_zip_dict
  WHERE name = @long_dictionary_name;
SELECT zip_dict = @long_dictionary_data AS long_zip_dict_data_must_match
  FROM information_schema.xtradb_zip_dict
  WHERE name = 'd13';

# creating a compression dictionary with a name already taken is an error
--error ER_COMPRESSION_DICTIONARY_EXISTS
CREATE COMPRESSION_DICTIONARY d1('data');

--let $dict_name=d1
--let $table_name=t1

# getting compression dictionary id for d1
eval SELECT id INTO @dict_id FROM information_schema.xtradb_zip_dict
  WHERE name = '$dict_name';

# creating a new table t1 with 2 compressed columns (with and without dictionary)
eval CREATE TABLE $table_name(
  id INT,
  a BLOB COLUMN_FORMAT COMPRESSED,
  b BLOB COLUMN_FORMAT COMPRESSED WITH COMPRESSION_DICTIONARY $dict_name
) ENGINE=InnoDB;

# getting table id for t1
eval SELECT table_id INTO @table_id FROM information_schema.innodb_sys_tables
  WHERE name=CONCAT(DATABASE(), '/', '$table_name');

# the number of column<->dict_id links for t1 must be exactly one
SELECT COUNT(*) = 1 AS only_one_dictionary_reference FROM information_schema.xtradb_zip_dict_cols
  WHERE table_id = @table_id;

SELECT dict_id = @dict_id AS dict_ids_must_match FROM information_schema.xtradb_zip_dict_cols
  WHERE table_id = @table_id AND column_pos = 2;

# check if it is OK to refer to an empty dictionary
SET @long_string_value = REPEAT('a', 128);
INSERT INTO t1 VALUES(1, @long_string_value, @long_string_value);
SELECT a = @long_string_value AS a_match, b = @long_string_value AS b_match FROM t1 WHERE id = 1;

# dropping non-existing compression dictionary must generate an error
--error ER_COMPRESSION_DICTIONARY_DOES_NOT_EXIST
DROP COMPRESSION_DICTIONARY d100;

# dropping a dictionary in use must generate an error
--error ER_COMPRESSION_DICTIONARY_IS_REFERENCED
--eval DROP COMPRESSION_DICTIONARY $dict_name

# dropping existing compression dictionary must be reflected in "xtradb_zip_dict"
DROP COMPRESSION_DICTIONARY d13;

SELECT COUNT(*) = 0 AS dict_must_be_deleted
  FROM information_schema.xtradb_zip_dict
  WHERE name = 'd13';

# droppping all created compression dictionaries except d1
DROP COMPRESSION_DICTIONARY d2;
DROP COMPRESSION_DICTIONARY d3;
DROP COMPRESSION_DICTIONARY d4;
DROP COMPRESSION_DICTIONARY d5;
DROP COMPRESSION_DICTIONARY d6;
DROP COMPRESSION_DICTIONARY d7;
DROP COMPRESSION_DICTIONARY d8;
DROP COMPRESSION_DICTIONARY d9;
DROP COMPRESSION_DICTIONARY d10;
DROP COMPRESSION_DICTIONARY d11;
DROP COMPRESSION_DICTIONARY d12;
--eval DROP COMPRESSION_DICTIONARY $long_dictionary_name

# check changes if the changes are reflected properlyt in "xtradb_zip_dict"
SELECT id, name, zip_dict, LENGTH(zip_dict)
  FROM information_schema.xtradb_zip_dict;

# cleanup
DROP TABLE t1;
